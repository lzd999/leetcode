215\. 数组中的第K个最大元素
-----------------

给定整数数组 `nums` 和整数 `k`，请返回数组中第 `k` 个最大的元素。

请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。

你必须设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

**示例 1:**

**输入:** `[3,2,1,5,6,4],` k = 2
**输出:** 5

**示例 2:**

**输入:** `[3,2,3,1,2,4,5,5,6],` k = 4
**输出:** 4

**提示：**

*   `1 <= k <= nums.length <= 10^5`
*   `-10^4 <= nums[i] <= 10^4`

347\. 前 K 个高频元素
---------------

给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。

**示例 1:**

**输入:** nums = \[1,1,1,2,2,3\], k = 2
**输出:** \[1,2\]

**示例 2:**

**输入:** nums = \[1\], k = 1
**输出:** \[1\]

**提示：**

*   `1 <= nums.length <= 10^5`
*   `k` 的取值范围是 `[1, 数组中不相同的元素的个数]`
*   题目数据保证答案唯一，换句话说，数组中前 `k` 个高频元素的集合是唯一的

**进阶：**你所设计算法的时间复杂度 **必须** 优于 `O(n log n)` ，其中 `n` 是数组大小。

295\. 数据流的中位数
-------------

**中位数**是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。

*   例如 `arr = [2,3,4]` 的中位数是 `3` 。
*   例如 `arr = [2,3]` 的中位数是 `(2 + 3) / 2 = 2.5` 。

实现 MedianFinder 类:

*   `MedianFinder()` 初始化 `MedianFinder` 对象。
    
*   `void addNum(int num)` 将数据流中的整数 `num` 添加到数据结构中。
    
*   `double findMedian()` 返回到目前为止所有元素的中位数。与实际答案相差 `10-5` 以内的答案将被接受。
    

**示例 1：**

**输入**
\["MedianFinder", "addNum", "addNum", "findMedian", "addNum", "findMedian"\]
\[\[\], \[1\], \[2\], \[\], \[3\], \[\]\]
**输出**
\[null, null, null, 1.5, null, 2.0\]

**解释**
MedianFinder medianFinder = new MedianFinder();
medianFinder.addNum(1);    // arr = \[1\]
medianFinder.addNum(2);    // arr = \[1, 2\]
medianFinder.findMedian(); // 返回 1.5 ((1 + 2) / 2)
medianFinder.addNum(3);    // arr\[1, 2, 3\]
medianFinder.findMedian(); // return 2.0

**提示:**

*   `-10^5 <= num <= 10^5`
*   在调用 `findMedian` 之前，数据结构中至少有一个元素
*   最多 `5 × 10^4` 次调用 `addNum` 和 `findMedian`

