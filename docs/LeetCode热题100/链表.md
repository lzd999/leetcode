160\. 相交链表
----------

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 。

图示两个链表在节点 `c1` 开始相交**：**

[![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)

题目数据 **保证** 整个链式结构中不存在环。

**注意**，函数返回结果后，链表必须 **保持其原始结构** 。

**自定义评测：**

**评测系统** 的输入如下（你设计的程序 **不适用** 此输入）：

*   `intersectVal` - 相交的起始节点的值。如果不存在相交节点，这一值为 `0`
*   `listA` - 第一个链表
*   `listB` - 第二个链表
*   `skipA` - 在 `listA` 中（从头节点开始）跳到交叉节点的节点数
*   `skipB` - 在 `listB` 中（从头节点开始）跳到交叉节点的节点数

评测系统将根据这些输入创建链式数据结构，并将两个头节点 `headA` 和 `headB` 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 **视作正确答案** 。

**示例 1：**

[![](https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)

**输入：**intersectVal = 8, listA = \[4,1,8,4,5\], listB = \[5,6,1,8,4,5\], skipA = 2, skipB = 3
**输出：**Intersected at '8'
**解释：**相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 \[4,1,8,4,5\]，链表 B 为 \[5,6,1,8,4,5\]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。

**示例 2：**

[![](https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png)

**输入：**intersectVal = 2, listA = \[1,9,1,2,4\], listB = \[3,2,4\], skipA = 3, skipB = 1
**输出：**Intersected at '2'
**解释：**相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 \[1,9,1,2,4\]，链表 B 为 \[3,2,4\]。
在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。

**示例 3：**

[![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png)

**输入：**intersectVal = 0, listA = \[2,6,4\], listB = \[1,5\], skipA = 3, skipB = 2
**输出：**null
**解释：**从各自的表头开始算起，链表 A 为 \[2,6,4\]，链表 B 为 \[1,5\]。
由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
这两个链表不相交，因此返回 null 。

**提示：**

*   `listA` 中节点数目为 `m`
*   `listB` 中节点数目为 `n`
*   `1 <= m, n <= 3 × 10^4`
*   `1 <= Node.val <= 10^5`
*   `0 <= skipA <= m`
*   `0 <= skipB <= n`
*   如果 `listA` 和 `listB` 没有交点，`intersectVal` 为 `0`
*   如果 `listA` 和 `listB` 有交点，`intersectVal == listA[skipA] == listB[skipB]`

**进阶：**你能否设计一个时间复杂度 `O(m + n)` 、仅用 `O(1)` 内存的解决方案？

206\. 反转链表
----------

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

**示例 1：**

![](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)

**输入：**head = \[1,2,3,4,5\]
**输出：**\[5,4,3,2,1\]

**示例 2：**

![](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)

**输入：**head = \[1,2\]
**输出：**\[2,1\]

**示例 3：**

**输入：**head = \[\]
**输出：**\[\]

**提示：**

*   链表中节点的数目范围是 `[0, 5000]`
*   `-5000 <= Node.val <= 5000`

**进阶：**链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？

234\. 回文链表
----------

给你一个单链表的头节点 `head` ，请你判断该链表是否为

回文链表

。如果是，返回 `true` ；否则，返回 `false` 。

**示例 1：**

![](https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg)

**输入：**head = \[1,2,2,1\]
**输出：**true

**示例 2：**

![](https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg)

**输入：**head = \[1,2\]
**输出：**false

**提示：**

*   链表中节点数目在范围`[1, 105]` 内
*   `0 <= Node.val <= 9`

**进阶：**你能否用 `O(n)` 时间复杂度和 `O(1)` 空间复杂度解决此题？

141\. 环形链表
----------

给你一个链表的头节点 `head` ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。**注意：`pos` 不作为参数进行传递** 。仅仅是为了标识链表的实际情况。

_如果链表中存在环_ ，则返回 `true` 。 否则，返回 `false` 。

**示例 1：**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)

**输入：**head = \[3,2,0,-4\], pos = 1
**输出：**true
**解释：**链表中有一个环，其尾部连接到第二个节点。

**示例 2：**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)

**输入：**head = \[1,2\], pos = 0
**输出：**true
**解释：**链表中有一个环，其尾部连接到第一个节点。

**示例 3：**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png)

**输入：**head = \[1\], pos = -1
**输出：**false
**解释：**链表中没有环。

**提示：**

*   链表中节点的数目范围是 `[0, 104]`
*   `-105 <= Node.val <= 105`
*   `pos` 为 `-1` 或者链表中的一个 **有效索引** 。

**进阶：**你能用 `O(1)`（即，常量）内存解决此问题吗？

142\. 环形链表 II
-------------

给定一个链表的头节点  `head` ，返回链表开始入环的第一个节点。 _如果链表无环，则返回 `null`。_

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（**索引从 0 开始**）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。

**不允许修改** 链表。

**示例 1：**

![](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png)

**输入：**head = \[3,2,0,-4\], pos = 1
**输出：**返回索引为 1 的链表节点
**解释：**链表中有一个环，其尾部连接到第二个节点。

**示例 2：**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)

**输入：**head = \[1,2\], pos = 0
**输出：**返回索引为 0 的链表节点
**解释：**链表中有一个环，其尾部连接到第一个节点。

**示例 3：**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png)

**输入：**head = \[1\], pos = -1
**输出：**返回 null
**解释：**链表中没有环。

**提示：**

*   链表中节点的数目范围在范围 `[0, 104]` 内
*   `-105 <= Node.val <= 105`
*   `pos` 的值为 `-1` 或者链表中的一个有效索引

**进阶：**你是否可以使用 `O(1)` 空间解决此题？

21\. 合并两个有序链表
-------------

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

**示例 1：**

![](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg)

**输入：**l1 = \[1,2,4\], l2 = \[1,3,4\]
**输出：**\[1,1,2,3,4,4\]

**示例 2：**

**输入：**l1 = \[\], l2 = \[\]
**输出：**\[\]

**示例 3：**

**输入：**l1 = \[\], l2 = \[0\]
**输出：**\[0\]

**提示：**

*   两个链表的节点数目范围是 `[0, 50]`
*   `-100 <= Node.val <= 100`
*   `l1` 和 `l2` 均按 **非递减顺序** 排列

19\. 删除链表的倒数第 N 个结点
-------------------

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

**示例 1：**

![](https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg)

**输入：**head = \[1,2,3,4,5\], n = 2
**输出：**\[1,2,3,5\]

**示例 2：**

**输入：**head = \[1\], n = 1
**输出：**\[\]

**示例 3：**

**输入：**head = \[1,2\], n = 1
**输出：**\[1\]

**提示：**

*   链表中结点的数目为 `sz`
*   `1 <= sz <= 30`
*   `0 <= Node.val <= 100`
*   `1 <= n <= sz`

**进阶：**你能尝试使用一趟扫描实现吗？

24\. 两两交换链表中的节点
---------------

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

**示例 1：**

![](https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg)

**输入：**head = \[1,2,3,4\]
**输出：**\[2,1,4,3\]

**示例 2：**

**输入：**head = \[\]
**输出：**\[\]

**示例 3：**

**输入：**head = \[1\]
**输出：**\[1\]

**提示：**

*   链表中节点的数目在范围 `[0, 100]` 内
*   `0 <= Node.val <= 100`

25\. K 个一组翻转链表
--------------

给你链表的头节点 `head` ，每 `k` 个节点一组进行翻转，请你返回修改后的链表。

`k` 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 `k` 的整数倍，那么请将最后剩余的节点保持原有顺序。

你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

**示例 1：**

![](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg)

**输入：**head = \[1,2,3,4,5\], k = 2
**输出：**\[2,1,4,3,5\]

**示例 2：**

![](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg)

**输入：**head = \[1,2,3,4,5\], k = 3
**输出：**\[3,2,1,4,5\]

**提示：**

*   链表中的节点数目为 `n`
*   `1 <= k <= n <= 5000`
*   `0 <= Node.val <= 1000`

**进阶：**你可以设计一个只用 `O(1)` 额外内存空间的算法解决此问题吗？

138\. 随机链表的复制
-------------

给你一个长度为 `n` 的链表，每个节点包含一个额外增加的随机指针 `random` ，该指针可以指向链表中的任何节点或空节点。

构造这个链表的 **[深拷贝](https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin)**。 深拷贝应该正好由 `n` 个 **全新** 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 `next` 指针和 `random` 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。**复制链表中的指针都不应指向原链表中的节点** 。

例如，如果原链表中有 `X` 和 `Y` 两个节点，其中 `X.random --> Y` 。那么在复制链表中对应的两个节点 `x` 和 `y` ，同样有 `x.random --> y` 。

返回复制链表的头节点。

用一个由 `n` 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 `[val, random_index]` 表示：

*   `val`：一个表示 `Node.val` 的整数。
*   `random_index`：随机指针指向的节点索引（范围从 `0` 到 `n-1`）；如果不指向任何节点，则为  `null` 。

你的代码 **只** 接受原链表的头节点 `head` 作为传入参数。

**示例 1：**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png)

**输入：**head = \[\[7,null\],\[13,0\],\[11,4\],\[10,2\],\[1,0\]\]
**输出：**\[\[7,null\],\[13,0\],\[11,4\],\[10,2\],\[1,0\]\]

**示例 2：**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png)

**输入：**head = \[\[1,1\],\[2,1\]\]
**输出：**\[\[1,1\],\[2,1\]\]

**示例 3：**

**![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e3.png)**

**输入：**head = \[\[3,null\],\[3,0\],\[3,null\]\]
**输出：**\[\[3,null\],\[3,0\],\[3,null\]\]

**提示：**

*   `0 <= n <= 1000`
*   `-10^4 <= Node.val <= 10^4`
*   `Node.random` 为 `null` 或指向链表中的节点。

148\. 排序链表
----------

给你链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表** 。

**示例 1：**

![](https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg)

**输入：**head = \[4,2,1,3\]
**输出：**\[1,2,3,4\]

**示例 2：**

![](https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg)

**输入：**head = \[-1,5,3,4,0\]
**输出：**\[-1,0,3,4,5\]

**示例 3：**

**输入：**head = \[\]
**输出：**\[\]

**提示：**

*   链表中节点的数目在范围 `[0, 5 × 10^4]` 内
*   `-10^5 <= Node.val <= 10^5`

**进阶：**你可以在 `O(nlogn)` 时间复杂度和常数级空间复杂度下，对链表进行排序吗？

23\. 合并 K 个升序链表
---------------

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

**示例 1：**

**输入：**lists = \[\[1,4,5\],\[1,3,4\],\[2,6\]\]
**输出：**\[1,1,2,3,4,4,5,6\]
**解释：**链表数组如下：
\[
  1->4->5,
  1->3->4,
  2->6
\]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6

**示例 2：**

**输入：**lists = \[\]
**输出：**\[\]

**示例 3：**

**输入：**lists = \[\[\]\]
**输出：**\[\]

**提示：**

*   `k == lists.length`
*   `0 <= k <= 10^4`
*   `0 <= lists[i].length <= 500`
*   `-10^4 <= lists[i][j] <= 10^4`
*   `lists[i]` 按 **升序** 排列
*   `lists[i].length` 的总和不超过 `10^4`

146\. LRU 缓存
------------

请你设计并实现一个满足  [LRU (最近最少使用) 缓存](https://baike.baidu.com/item/LRU) 约束的数据结构。

实现 `LRUCache` 类：

*   `LRUCache(int capacity)` 以 **正整数** 作为容量 `capacity` 初始化 LRU 缓存
*   `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1` 。
*   `void put(int key, int value)` 如果关键字 `key` 已经存在，则变更其数据值 `value` ；如果不存在，则向缓存中插入该组 `key-value` 。如果插入操作导致关键字数量超过 `capacity` ，则应该 **逐出** 最久未使用的关键字。

函数 `get` 和 `put` 必须以 `O(1)` 的平均时间复杂度运行。

**示例：**

**输入**
\["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"\]
\[\[2\], \[1, 1\], \[2, 2\], \[1\], \[3, 3\], \[2\], \[4, 4\], \[1\], \[3\], \[4\]\]
**输出**
\[null, null, null, 1, null, -1, null, -1, 3, 4\]

**解释**
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 {1=1}
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4

**提示：**

*   `1 <= capacity <= 3000`
*   `0 <= key <= 10000`
*   `0 <= value <= 10^5`
*   最多调用 `2 × 10^5` 次 `get` 和 `put`

