94\. 二叉树的中序遍历
-------------

给定一个二叉树的根节点 `root` ，返回 _它的 **中序** 遍历_ 。

**示例 1：**

![](https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg)

**输入：**root = \[1,null,2,3\]
**输出：**\[1,3,2\]

**示例 2：**

**输入：**root = \[\]
**输出：**\[\]

**示例 3：**

**输入：**root = \[1\]
**输出：**\[1\]

**提示：**

*   树中节点数目在范围 `[0, 100]` 内
*   `-100 <= Node.val <= 100`

**进阶:** 递归算法很简单，你可以通过迭代算法完成吗？

104\. 二叉树的最大深度
--------------

给定一个二叉树 `root` ，返回其最大深度。

二叉树的 **最大深度** 是指从根节点到最远叶子节点的最长路径上的节点数。

**示例 1：**

![](https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg)

**输入：**root = \[3,9,20,null,null,15,7\]
**输出：**3

**示例 2：**

**输入：**root = \[1,null,2\]
**输出：**2

**提示：**

*   树中节点的数量在 `[0, 10^4]` 区间内。
*   `-100 <= Node.val <= 100`

226\. 翻转二叉树
-----------

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

**示例 1：**

![](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg)

**输入：**root = \[4,2,7,1,3,6,9\]
**输出：**\[4,7,2,9,6,3,1\]

**示例 2：**

![](https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg)

**输入：**root = \[2,1,3\]
**输出：**\[2,3,1\]

**示例 3：**

**输入：**root = \[\]
**输出：**\[\]

**提示：**

*   树中节点数目范围在 `[0, 100]` 内
*   `-100 <= Node.val <= 100`

101\. 对称二叉树
-----------

给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

**示例 1：**

![](https://pic.leetcode.cn/1698026966-JDYPDU-image.png)

**输入：**root = \[1,2,2,3,4,4,3\]
**输出：**true

**示例 2：**

![](https://pic.leetcode.cn/1698027008-nPFLbM-image.png)

**输入：**root = \[1,2,2,null,3,null,3\]
**输出：**false

**提示：**

*   树中节点数目在范围 `[1, 1000]` 内
*   `-100 <= Node.val <= 100`

**进阶：**你可以运用递归和迭代两种方法解决这个问题吗？

543\. 二叉树的直径
------------

给你一棵二叉树的根节点，返回该树的 **直径** 。

二叉树的 **直径** 是指树中任意两个节点之间最长路径的 **长度** 。这条路径可能经过也可能不经过根节点 `root` 。

两节点之间路径的 **长度** 由它们之间边数表示。

**示例 1：**

![](https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg)

**输入：**root = \[1,2,3,4,5\]
**输出：**3
**解释：**3 ，取路径 \[4,2,1,3\] 或 \[5,2,1,3\] 的长度。

**示例 2：**

**输入：**root = \[1,2\]
**输出：**1

**提示：**

*   树中节点数目在范围 `[1, 10^4]` 内
*   `-100 <= Node.val <= 100`

102\. 二叉树的层序遍历
--------------

给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

**示例 1：**

![](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)

**输入：**root = \[3,9,20,null,null,15,7\]
**输出：**\[\[3\],\[9,20\],\[15,7\]\]

**示例 2：**

**输入：**root = \[1\]
**输出：**\[\[1\]\]

**示例 3：**

**输入：**root = \[\]
**输出：**\[\]

**提示：**

*   树中节点数目在范围 `[0, 2000]` 内
*   `-1000 <= Node.val <= 1000`

108\. 将有序数组转换为二叉搜索树
-------------------

给你一个整数数组 `nums` ，其中元素已经按 **升序** 排列，请你将其转换为一棵

平衡

二叉搜索树。

**示例 1：**

![](https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg)

**输入：**nums = \[-10,-3,0,5,9\]
**输出：**\[0,-3,9,-10,null,5\]
**解释：**\[0,-10,5,null,-3,null,9\] 也将被视为正确答案：
![](https://assets.leetcode.com/uploads/2021/02/18/btree2.jpg)

**示例 2：**

![](https://assets.leetcode.com/uploads/2021/02/18/btree.jpg)

**输入：**nums = \[1,3\]
**输出：**\[3,1\]
**解释：**\[1,null,3\] 和 \[3,1\] 都是高度平衡二叉搜索树。

**提示：**

*   `1 <= nums.length <= 10^4`
*   `-10^4 <= nums[i] <= 10^4`
*   `nums` 按 **严格递增** 顺序排列

98\. 验证二叉搜索树
------------

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

**有效** 二叉搜索树定义如下：

*   节点的左
    
    子树
    
    只包含 **小于** 当前节点的数。
*   节点的右子树只包含 **大于** 当前节点的数。
*   所有左子树和右子树自身必须也是二叉搜索树。

**示例 1：**

![](https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg)

**输入：**root = \[2,1,3\]
**输出：**true

**示例 2：**

![](https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg)

**输入：**root = \[5,1,4,null,null,3,6\]
**输出：**false
**解释：**根节点的值是 5 ，但是右子节点的值是 4 。

**提示：**

*   树中节点数目范围在`[1, 10^4]` 内
*   `-2^31 <= Node.val <= 2^31 - 1`

230\. 二叉搜索树中第 K 小的元素
--------------------

给定一个二叉搜索树的根节点 `root` ，和一个整数 `k` ，请你设计一个算法查找其中第 `k` 小的元素（从 1 开始计数）。

**示例 1：**

![](https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg)

**输入：**root = \[3,1,4,null,2\], k = 1
**输出：**1

**示例 2：**

![](https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg)

**输入：**root = \[5,3,6,2,4,null,null,1\], k = 3
**输出：**3

**提示：**

*   树中的节点数为 `n` 。
*   `1 <= k <= n <= 10^4`
*   `0 <= Node.val <= 10^4`

**进阶：**如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 `k` 小的值，你将如何优化算法？

199\. 二叉树的右视图
-------------

给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

**示例 1:**

![](https://assets.leetcode.com/uploads/2021/02/14/tree.jpg)

**输入:** \[1,2,3,null,5,null,4\]
**输出:** \[1,3,4\]

**示例 2:**

**输入:** \[1,null,3\]
**输出:** \[1,3\]

**示例 3:**

**输入:** \[\]
**输出:** \[\]

**提示:**

*   二叉树的节点个数的范围是 `[0,100]`
*   `-100 <= Node.val <= 100` 

114\. 二叉树展开为链表
--------------

给你二叉树的根结点 `root` ，请你将它展开为一个单链表：

*   展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null` 。
*   展开后的单链表应该与二叉树 [**先序遍历**](https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin) 顺序相同。

**示例 1：**

![](https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg)

**输入：**root = \[1,2,5,3,4,null,6\]
**输出：**\[1,null,2,null,3,null,4,null,5,null,6\]

**示例 2：**

**输入：**root = \[\]
**输出：**\[\]

**示例 3：**

**输入：**root = \[0\]
**输出：**\[0\]

**提示：**

*   树中结点数在范围 `[0, 2000]` 内
*   `-100 <= Node.val <= 100`

**进阶：**你可以使用原地算法（`O(1)` 额外空间）展开这棵树吗？

105\. 从前序与中序遍历序列构造二叉树
---------------------

给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。

**示例 1:**

![](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)

**输入:** preorder = \[3,9,20,15,7\], inorder = \[9,3,15,20,7\]
**输出:** \[3,9,20,null,null,15,7\]

**示例 2:**

**输入:** preorder = \[-1\], inorder = \[-1\]
**输出:** \[-1\]

**提示:**

*   `1 <= preorder.length <= 3000`
*   `inorder.length == preorder.length`
*   `-3000 <= preorder[i], inorder[i] <= 3000`
*   `preorder` 和 `inorder` 均 **无重复** 元素
*   `inorder` 均出现在 `preorder`
*   `preorder` **保证** 为二叉树的前序遍历序列
*   `inorder` **保证** 为二叉树的中序遍历序列

437\. 路径总和 III
--------------

给定一个二叉树的根节点 `root` ，和一个整数 `targetSum` ，求该二叉树里节点值之和等于 `targetSum` 的 **路径** 的数目。

**路径** 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

**示例 1：**

![](https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg)

**输入：**root = \[10,5,-3,3,2,null,11,3,-2,null,1\], targetSum = 8
**输出：**3
**解释：**和等于 8 的路径有 3 条，如图所示。

**示例 2：**

**输入：**root = \[5,4,8,11,null,13,4,7,2,null,null,5,1\], targetSum = 22
**输出：**3

**提示:**

*   二叉树的节点个数的范围是 `[0,1000]`
*   `-10^9 <= Node.val <= 10^9` 
*   `-1000 <= targetSum <= 1000` 

236\. 二叉树的最近公共祖先
----------------

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

**示例 1：**

![](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

**输入：**root = \[3,5,1,6,2,0,8,null,null,7,4\], p = 5, q = 1
**输出：**3
**解释：**节点 `5` 和节点 `1` 的最近公共祖先是节点 `3 。`

**示例 2：**

![](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

**输入：**root = \[3,5,1,6,2,0,8,null,null,7,4\], p = 5, q = 4
**输出：**5
**解释：**节点 `5` 和节点 `4` 的最近公共祖先是节点 `5 。`因为根据定义最近公共祖先节点可以为节点本身。

**示例 3：**

**输入：**root = \[1,2\], p = 1, q = 2
**输出：**1

**提示：**

*   树中节点数目在范围 `[2, 10^5]` 内。
*   `-109 <= Node.val <= 10^9`
*   所有 `Node.val` `互不相同` 。
*   `p != q`
*   `p` 和 `q` 均存在于给定的二叉树中。

124\. 二叉树中的最大路径和
----------------

二叉树中的 **路径** 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 **至多出现一次** 。该路径 **至少包含一个** 节点，且不一定经过根节点。

**路径和** 是路径中各节点值的总和。

给你一个二叉树的根节点 `root` ，返回其 **最大路径和** 。

**示例 1：**

![](https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg)

**输入：**root = \[1,2,3\]
**输出：**6
**解释：**最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6

**示例 2：**

![](https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg)

**输入：**root = \[-10,9,20,null,null,15,7\]
**输出：**42
**解释：**最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42

**提示：**

*   树中节点数目范围是 `[1, 3 × 10^4]`
*   `-1000 <= Node.val <= 1000`
