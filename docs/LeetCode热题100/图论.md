200\. 岛屿数量
----------

给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

**示例 1：**

**输入：**grid = \[
  \["1","1","1","1","0"\],
  \["1","1","0","1","0"\],
  \["1","1","0","0","0"\],
  \["0","0","0","0","0"\]
\]
**输出：**1

**示例 2：**

**输入：**grid = \[
  \["1","1","0","0","0"\],
  \["1","1","0","0","0"\],
  \["0","0","1","0","0"\],
  \["0","0","0","1","1"\]
\]
**输出：**3

**提示：**

*   `m == grid.length`
*   `n == grid[i].length`
*   `1 <= m, n <= 300`
*   `grid[i][j]` 的值为 `'0'` 或 `'1'`

994\. 腐烂的橘子
-----------

在给定的 `m x n` 网格 `grid` 中，每个单元格可以有以下三个值之一：

*   值 `0` 代表空单元格；
*   值 `1` 代表新鲜橘子；
*   值 `2` 代表腐烂的橘子。

每分钟，腐烂的橘子 **周围 4 个方向上相邻** 的新鲜橘子都会腐烂。

返回 _直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 `-1`_ 。

**示例 1：**

**![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/oranges.png)**

**输入：**grid = \[\[2,1,1\],\[1,1,0\],\[0,1,1\]\]
**输出：**4

**示例 2：**

**输入：**grid = \[\[2,1,1\],\[0,1,1\],\[1,0,1\]\]
**输出：**\-1
**解释：**左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个方向上。

**示例 3：**

**输入：**grid = \[\[0,2\]\]
**输出：**0
**解释：**因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。

**提示：**

*   `m == grid.length`
*   `n == grid[i].length`
*   `1 <= m, n <= 10`
*   `grid[i][j]` 仅为 `0`、`1` 或 `2`

207\. 课程表
---------

你这个学期必须选修 `numCourses` 门课程，记为 `0` 到 `numCourses - 1` 。

在选修某些课程之前需要一些先修课程。 先修课程按数组 `prerequisites` 给出，其中 `prerequisites[i] = [ai, bi]` ，表示如果要学习课程 `ai` 则 **必须** 先学习课程  `bi` 。

*   例如，先修课程对 `[0, 1]` 表示：想要学习课程 `0` ，你需要先完成课程 `1` 。

请你判断是否可能完成所有课程的学习？如果可以，返回 `true` ；否则，返回 `false` 。

**示例 1：**

**输入：**numCourses = 2, prerequisites = \[\[1,0\]\]
**输出：**true
**解释：**总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。

**示例 2：**

**输入：**numCourses = 2, prerequisites = \[\[1,0\],\[0,1\]\]
**输出：**false
**解释：**总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。

**提示：**

*   `1 <= numCourses <= 2000`
*   `0 <= prerequisites.length <= 5000`
*   `prerequisites[i].length == 2`
*   `0 <= ai, bi < numCourses`
*   `prerequisites[i]` 中的所有课程对 **互不相同**

208\. 实现 Trie (前缀树)
-------------------

**[Trie](https://baike.baidu.com/item/字典树/9825209?fr=aladdin)**（发音类似 "try"）或者说 **前缀树** 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。

请你实现 Trie 类：

*   `Trie()` 初始化前缀树对象。
*   `void insert(String word)` 向前缀树中插入字符串 `word` 。
*   `boolean search(String word)` 如果字符串 `word` 在前缀树中，返回 `true`（即，在检索之前已经插入）；否则，返回 `false` 。
*   `boolean startsWith(String prefix)` 如果之前已经插入的字符串 `word` 的前缀之一为 `prefix` ，返回 `true` ；否则，返回 `false` 。

**示例：**

**输入**
\["Trie", "insert", "search", "search", "startsWith", "insert", "search"\]
\[\[\], \["apple"\], \["apple"\], \["app"\], \["app"\], \["app"\], \["app"\]\]
**输出**
\[null, null, true, false, true, null, true\]

**解释**
Trie trie = new Trie();
trie.insert("apple");
trie.search("apple");   // 返回 True
trie.search("app");     // 返回 False
trie.startsWith("app"); // 返回 True
trie.insert("app");
trie.search("app");     // 返回 True

**提示：**

*   `1 <= word.length, prefix.length <= 2000`
*   `word` 和 `prefix` 仅由小写英文字母组成
*   `insert`、`search` 和 `startsWith` 调用次数 **总计** 不超过 `3 * 10^4` 次

