53\. 最大子数组和
-----------

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组**

是数组中的一个连续部分。

**示例 1：**

**输入：**nums = \[-2,1,-3,4,-1,2,1,-5,4\]
**输出：**6
**解释：**连续子数组 \[4,-1,2,1\] 的和最大，为 6 。

**示例 2：**

**输入：**nums = \[1\]
**输出：**1

**示例 3：**

**输入：**nums = \[5,4,-1,7,8\]
**输出：**23

**提示：**

*   `1 <= nums.length <= 10^5`
*   `-10^4 <= nums[i] <= 10^4`

**进阶：**如果你已经实现复杂度为 `O(n)` 的解法，尝试使用更为精妙的 **分治法** 求解。

2606\. 找到最大开销的子字符串
------------------

给你一个字符串 `s` ，一个字符 **互不相同** 的字符串 `chars` 和一个长度与 `chars` 相同的整数数组 `vals` 。

**子字符串的开销** 是一个子字符串中所有字符对应价值之和。空字符串的开销是 `0` 。

**字符的价值** 定义如下：

*   如果字符不在字符串 `chars` 中，那么它的价值是它在字母表中的位置（下标从 **1** 开始）。
    *   比方说，`'a'` 的价值为 `1` ，`'b'` 的价值为 `2` ，以此类推，`'z'` 的价值为 `26` 。
*   否则，如果这个字符在 `chars` 中的位置为 `i` ，那么它的价值就是 `vals[i]` 。

请你返回字符串 `s` 的所有子字符串中的最大开销。

**示例 1：**

**输入：**s = "adaa", chars = "d", vals = \[-1000\]
**输出：**2
**解释：**字符 "a" 和 "d" 的价值分别为 1 和 -1000 。
最大开销子字符串是 "aa" ，它的开销为 1 + 1 = 2 。
2 是最大开销。

**示例 2：**

**输入：**s = "abc", chars = "abc", vals = \[-1,-1,-1\]
**输出：**0
**解释：**字符 "a" ，"b" 和 "c" 的价值分别为 -1 ，-1 和 -1 。
最大开销子字符串是 "" ，它的开销为 0 。
0 是最大开销。

**提示：**

*   `1 <= s.length <= 10^5`
*   `s` 只包含小写英文字母。
*   `1 <= chars.length <= 26`
*   `chars` 只包含小写英文字母，且 **互不相同** 。
*   `vals.length == chars.length`
*   `-1000 <= vals[i] <= 1000`

1749\. 任意子数组和的绝对值的最大值
---------------------

给你一个整数数组 `nums` 。一个子数组 `[numsl, numsl+1, ..., numsr-1, numsr]` 的 **和的绝对值** 为 `abs(numsl + numsl+1 + ... + numsr-1 + numsr)` 。

请你找出 `nums` 中 **和的绝对值** 最大的任意子数组（**可能为空**），并返回该 **最大值** 。

`abs(x)` 定义如下：

*   如果 `x` 是负整数，那么 `abs(x) = -x` 。
*   如果 `x` 是非负整数，那么 `abs(x) = x` 。

**示例 1：**

**输入：**nums = \[1,-3,2,3,-4\]
**输出：**5
**解释：**子数组 \[2,3\] 和的绝对值最大，为 abs(2+3) = abs(5) = 5 。

**示例 2：**

**输入：**nums = \[2,-5,1,-4,3,-2\]
**输出：**8
**解释：**子数组 \[-5,1,-4\] 和的绝对值最大，为 abs(-5+1-4) = abs(-8) = 8 。

**提示：**

*   `1 <= nums.length <= 10^5`
*   `-10^4 <= nums[i] <= 10^4`

1191\. K 次串联后最大子数组之和
--------------------

给定一个整数数组 `arr` 和一个整数 `k` ，通过重复 `k` 次来修改数组。

例如，如果 `arr = [1, 2]` ， `k = 3` ，那么修改后的数组将是 `[1, 2, 1, 2, 1, 2]` 。

返回修改后的数组中的最大的子数组之和。注意，子数组长度可以是 `0`，在这种情况下它的总和也是 `0`。

由于 **结果可能会很大**，需要返回的 `109 + 7` 的 **模** 。

**示例 1：**

**输入：**arr = \[1,2\], k = 3
**输出：**9

**示例 2：**

**输入：**arr = \[1,-2,1\], k = 5
**输出：**2

**示例 3：**

**输入：**arr = \[-1,-2\], k = 7
**输出：**0

**提示：**

*   `1 <= arr.length <= 10^5`
*   `1 <= k <= 10^5`
*   `-10^4 <= arr[i] <= 10^4`

918\. 环形子数组的最大和
---------------

给定一个长度为 `n` 的**环形整数数组** `nums` ，返回 _`nums` 的非空 **子数组** 的最大可能和_ 。

**环形数组** 意味着数组的末端将会与开头相连呈环状。形式上， `nums[i]` 的下一个元素是 `nums[(i + 1) % n]` ， `nums[i]` 的前一个元素是 `nums[(i - 1 + n) % n]` 。

**子数组** 最多只能包含固定缓冲区 `nums` 中的每个元素一次。形式上，对于子数组 `nums[i], nums[i + 1], ..., nums[j]` ，不存在 `i <= k1, k2 <= j` 其中 `k1 % n == k2 % n` 。

**示例 1：**

**输入：**nums = \[1,-2,3,-2\]
**输出：**3
**解释：**从子数组 \[3\] 得到最大和 3

**示例 2：**

**输入：**nums = \[5,-3,5\]
**输出：**10
**解释：**从子数组 \[5,5\] 得到最大和 5 + 5 = 10

**示例 3：**

**输入：**nums = \[3,-2,2,-3\]
**输出：**3
**解释：**从子数组 \[3\] 和 \[3,-2,2\] 都可以得到最大和 3

**提示：**

*   `n == nums.length`
*   `1 <= n <= 3 * 104`
*   `-3 * 104 <= nums[i] <= 3 * 104`

2321\. 拼接数组的最大分数
----------------

给你两个下标从 **0** 开始的整数数组 `nums1` 和 `nums2` ，长度都是 `n` 。

你可以选择两个整数 `left` 和 `right` ，其中 `0 <= left <= right < n` ，接着 **交换** 两个子数组 `nums1[left...right]` 和 `nums2[left...right]` 。

*   例如，设 `nums1 = [1,2,3,4,5]` 和 `nums2 = [11,12,13,14,15]` ，整数选择 `left = 1` 和 `right = 2`，那么 `nums1` 会变为 `[1,**_12_,_13_**,4,5]` 而 `nums2` 会变为 `[11,_**2,3**_,14,15]` 。

你可以选择执行上述操作 **一次** 或不执行任何操作。

数组的 **分数** 取 `sum(nums1)` 和 `sum(nums2)` 中的最大值，其中 `sum(arr)` 是数组 `arr` 中所有元素之和。

返回 **可能的最大分数** 。

**子数组** 是数组中连续的一个元素序列。`arr[left...right]` 表示子数组包含 `nums` 中下标 `left` 和 `right` 之间的元素**（含** 下标 `left` 和 `right` 对应元素**）**。

**示例 1：**

**输入：**nums1 = \[60,60,60\], nums2 = \[10,90,10\]
**输出：**210
**解释：**选择 left = 1 和 right = 1 ，得到 nums1 = \[60,_**90**_,60\] 和 nums2 = \[10,_**60**_,10\] 。
分数为 max(sum(nums1), sum(nums2)) = max(210, 80) = 210 。

**示例 2：**

**输入：**nums1 = \[20,40,20,70,30\], nums2 = \[50,20,50,40,20\]
**输出：**220
**解释：**选择 left = 3 和 right = 4 ，得到 nums1 = \[20,40,20,_**40,20**_\] 和 nums2 = \[50,20,50,_**70,30**_\] 。
分数为 max(sum(nums1), sum(nums2)) = max(140, 220) = 220 。

**示例 3：**

**输入：**nums1 = \[7,11,13\], nums2 = \[1,1,1\]
**输出：**31
**解释：**选择不交换任何子数组。
分数为 max(sum(nums1), sum(nums2)) = max(31, 3) = 31 。

**提示：**

*   `n == nums1.length == nums2.length`
*   `1 <= n <= 10^5`
*   `1 <= nums1[i], nums2[i] <= 10^4`

