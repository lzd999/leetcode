"""
思路：
观察示例 1，给定温度 temperatures = [73,74,75,71,69,72,76,73]，为什么答案是 [1,1,4,2,1,1,0,0]？
对于 73，下一个更大温度为 74，对应的索引为 1，因此对应的结果是 1；
对于 74，下一个更大温度为 75，对应的索引为 2，因此对应的结果是 1；
对于 75，下一个更大温度为 76，对应的索引为 6，因此对应的结果是 4；
……
直接的想法就是遍历数组，从左到右，依次计算每个元素右边第一个比它大的元素的索引，然后计算索引差值并保存到答案。
然而遍历每个元素右边获取更大元素索引的时间复杂度为 O(n)，能否优化？
是否存在这样一种数据结构，在尾部插入数据，在尾部删除数据，同时记录某个数据之前使得当前记录的所有数据单调递增或递减？
可以发现，单调栈即为满足条件的数据结构，即使用单调栈能使得获取每个元素的下一个最大元素的时间复杂度为 O(1)。
具体做法是：
定义单调栈，从左至右遍历数组，对每个元素，
如果栈不为空且当前元素大于栈顶对应元素，就弹出栈顶，记录栈顶索引与当前元素索引的差值，直到栈为空或者当前元素小于栈顶对应元素，否则将当前元素索引入栈，
即单调栈记录的是还没算出「下一个更大元素」的那些元素的索引；
也可以从右向左遍历数组，对每个元素，
如果栈不为空且当前元素大于等于栈顶对应元素，就弹出栈顶，直至栈为空或者当前元素小于栈顶对应元素，对应的答案即为栈顶对应元素索引与当前元素索引的差值，否则将当前元素索引入栈，
即单调栈记录的是「下一个更大元素」的候选元素的索引。
"""

from typing import List


class Solution739:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        n = len(temperatures)
        ans = [0] * n
        st = []
        for i, t in enumerate(temperatures):
            while st and t > temperatures[st[-1]]:
                j = st.pop()
                ans[j] = i - j
            st.append(i)
        # for i in range(n - 1, -1, -1):
        #     t = temperatures[i]
        #     while st and t >= temperatures[st[-1]]:
        #         st.pop()
        #     if st:
        #         ans[i] = st[-1] - i
        #     st.append(i)
        return ans
