"""
思路：
假设 n = 9，爬到第 9 阶台阶，有 2 种方法：
1.爬到第 8 阶台阶，然后爬 1 阶；
2.爬到第 7 阶台阶，然后爬 2 阶。
爬到第 8 阶台阶，又各自有 2 种方法：
1.爬到第 7 阶台阶，然后爬 1 阶；
2.爬到第 6 阶台阶，然后爬 2 阶。
可以发现，每次爬到第 i 阶台阶，都有 2 种方法：
1.爬到第 i-1 阶台阶，然后爬 1 阶；
2.爬到第 i-2 阶台阶，然后爬 2 阶。
这两种方法将原问题拆分成了与原问题相似、规模更小的子问题，可以用递归解决。
但递归过程中会出现大量的重复性计算，例如爬到第 9 阶台阶和爬到第 8 阶台阶，都需要计算爬到第 7 阶台阶，可以使用缓存避免这一类重复计算，
即使用记忆化搜索优化递归。
1.记忆化搜索
a.状态定义
定义 dfs(i) 表示爬到第 i 阶台阶的方法数。
b.状态转移方程
站在选哪一个的角度，有 2 种选法：
1.选择爬 1 阶，即 dfs(i-1)
2.选择爬 2 阶，即 dfs(i-2)。
根据加法原理，将上述两种方法得到的数相加即可，即 dfs(i) = dfs(i-1) + dfs(i-2)。
c.初始状态
dfs(0) = 1 表示爬到第 0 阶的方法只有 1 种，即不动；
dfs(1) = 1 表示爬到第 1 阶的方法也只有一种，即爬 1 阶。
d.答案
dfs(n)
2.1:1翻译成递推
dfs(i) => dp[i]
dfs(i) = dfs(i-1) + dfs(i-2) => dp[i] = dp[i-1] + dp[i-2]
dfs(0) = 1、dfs(1) = 1 => dp[0] = dp[1] = 1
dfs(n) => dp[-1]
3.空间优化（可选）
从状态转移方程可以发现，计算 dfs(i) 仅需要用到 dfs(i-1) 和 dfs(i-2)，因此可以使用两个变量保存这两个状态，而非使用数组保存全部状态。
"""

from functools import cache


class Solution70:
    def climbStairs(self, n: int) -> int:
        # @cache
        # def dfs(i):
        #     if i <= 1:
        #         return 1
        #     return dfs(i - 1) + dfs(i - 2)
        #
        # return dfs(n)

        # dp = [1, 1] + [0] * (n - 1)
        # for i in range(2, n + 1):
        #     dp[i] = dp[i - 1] + dp[i - 2]
        # return dp[-1]

        f0 = f1 = 1
        new_f = 0
        for _ in range(2, n + 1):
            new_f = f0 + f1
            f0 = f1
            f1 = new_f
        return f1
